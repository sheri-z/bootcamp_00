# :dart: 20240911 Daily LeetCode Practice

## [704.Binary Search](https://leetcode.com/problems/binary-search/)
### :computer: Difficulty: [Easy]

### Resources
- Problem Link: [LeetCode](https://leetcode.com/problems/binary-search/)
- Solution Explanation: [代码随想录 (ProgrammerCarl)](https://programmercarl.com/)
- Video Explanation: 
  - [手把手带你拆出正确的二分法 | 二分查找法 | 二分搜索法 1](https://www.bilibili.com/)
  - [手把手带你拆出正确的二分法 | 二分查找法 | 二分搜索法 2](https://www.bilibili.com/)
  - [LeetCode: 704. 二分查找_哔哩哔哩_bilibili](https://www.bilibili.com/)

---


### Explanation
- 左闭右闭：定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 
  因为定义target在[left, right]区间，所以有如下两点：

  1.while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  2.if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的有区间结束下标位置就是 middle - 1

### Code Implementation
```python
    def search(self, nums: List[int], target: int) -> int:
        left=0
        right=len(nums)-1
        while left<=right:
            mid = left + (right - left) // 2 #for Robust
            if target> nums[mid]:
                left = mid+1
            elif target<nums[mid]:
                right = mid-1
            else:
                return mid
        return -1


- 左闭右开：定义 target 是在一个在的区间里，也就是[left, right) 
有如下两点：

  1.while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
  2.if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

### Code Implementation
```python
    def search(self, nums: List[int], target: int) -> int:
        left,right=0,len(nums)-1
        while left< right :
            mid=left+(right-left)//2
            if target<nums[mid]:
                right=mid
            elif target>nums[mid]:
                left =mid+1
            else:return mid

        return -1

